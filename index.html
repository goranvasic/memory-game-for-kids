<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Memory game cards</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <script src="https://cdn.jsdelivr.net/npm/confetti-js@0.0.18/dist/index.min.js"></script>

  <style>
    .card-confetti {
      position: absolute;
      pointer-events: none;
      mix-blend-mode: screen;
      animation: firework-pop 1s ease-out forwards;
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, .45));
    }
  </style>

  <style>
    :root {
      --bg1: #0a3c54;
      --bg2: #072f43;
      --card: #eaf6ff;
      --title: #f2b21b;
      --btn: #2bd9c3;
      --btnText: #063a34;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      font-family: system-ui, sans-serif;
      background: radial-gradient(1200px 600px at 20% 10%, rgba(255, 255, 255, .1), transparent 60%),
      linear-gradient(180deg, var(--bg1), var(--bg2));
      color: white;
    }

    .wrap {
      width: min(860px, 92vw);
      text-align: center;
      padding: 24px;
    }

    h1 {
      color: var(--title);
      font-size: clamp(28px, 5vw, 52px);
      margin-bottom: 12px;
      font-weight: 800;
    }

    .meta {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-bottom: 12px;
    }

    .pill {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .15);
      font-size: 14px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px;
      max-width: 720px;
      margin: 0 auto;
    }

    .grid.grid-hidden {
      display: none;
    }

    .card {
      --front-color: var(--card);
      aspect-ratio: 1;
      background: rgba(255, 255, 255, .12);
      border-radius: 14px;
      display: grid;
      place-items: center;
      cursor: pointer;
      position: relative;
      overflow: visible; /* let confetti be visible outside */
    }

    @keyframes firework-pop {
      0% { transform: scale(.35); opacity: 0; }
      15% { opacity: 1; }
      100% { transform: scale(1.25); opacity: 0; }
    }

    .face {
      width: 82%;
      height: 82%;
      border-radius: 12px;
      display: grid;
      place-items: center;
      font-size: 40px;
      color: #0b2f3f;
      background: var(--front-color, var(--card)); /* only front differs */
    }

    .hidden .face {
      background: rgba(255, 255, 255, .08); /* backside stays the same */
      color: transparent;
      position: relative;
    }

    .hidden .face::after {
      content: "â˜…";
      color: white;
      font-size: 24px;
    }

    .matched {
      pointer-events: none;
      filter: saturate(1.2);
    }

    button {
      margin-top: 14px;
      padding: 12px 18px;
      border-radius: 12px;
      border: none;
      background: var(--btn);
      color: var(--btnText);
      font-weight: 800;
      cursor: pointer;
    }

    .status {
      min-height: 20px;
      margin-top: 8px;
      font-size: 14px;
    }

    .final-score {
      display: none;
      max-width: 720px;
      margin: 0 auto;
      padding: 48px 24px;
      border-radius: 18px;
      background: rgba(0, 0, 0, .25);
      font-size: clamp(22px, 4vw, 40px);
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    .final-score.visible {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @media (max-width: 520px) {
      .grid { grid-template-columns: repeat(3, 1fr); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Memory game cards</h1>

    <div class="meta">
      <div class="pill">Moves: <span id="moves">0</span></div>
      <div class="pill">Matched: <span id="matched">0</span>/6</div>
    </div>

    <div id="grid" class="grid"></div>
    <div id="finalScore" class="final-score" aria-live="polite"></div>
    <div id="status" class="status"></div>

    <button id="restartBtn">Restart game</button>
  </div>

  <script>
    // --- Config ---
    const PAIRS = 6;
    const PREVIEW_SECONDS = 3.5;
    const MISMATCH_DELAY = 0.6;

    const SYMBOLS = ["ðŸ¥¦","ðŸ‹","ðŸ¥•","ðŸ§…","ðŸ¥¬","ðŸŠ"];
    const PAIR_COLORS = ["#ff8fab","#ffd166","#80ed99","#64dfdf","#c77dff","#ffba93"];

    const SYMBOL_COLOR_MAP = Object.fromEntries(
      SYMBOLS.slice(0, PAIRS).map((sym, i) => [sym, PAIR_COLORS[i % PAIR_COLORS.length]])
    );

    // --- State ---
    let deck = [];
    let revealed = new Set();
    let matched = new Set();
    let firstPick = null;
    let lock = false;
    let moves = 0;

    // --- DOM ---
    const grid = document.getElementById("grid");
    const movesEl = document.getElementById("moves");
    const matchedEl = document.getElementById("matched");
    const statusEl = document.getElementById("status");
    const finalScoreEl = document.getElementById("finalScore");
    const restartBtn = document.getElementById("restartBtn");

    function updateMeta() {
      movesEl.textContent = String(moves);
      matchedEl.textContent = String(matched.size / 2);
    }

    function setStatus(t = "") {
      statusEl.textContent = t;
    }

    function newDeck() {
      const d = [...SYMBOLS.slice(0, PAIRS), ...SYMBOLS.slice(0, PAIRS)];
      for (let i = d.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [d[i], d[j]] = [d[j], d[i]];
      }
      return d;
    }

    function buildCard(idx, sym) {
      const c = document.createElement("div");
      c.classList.add("card", "hidden");
      c.dataset.idx = String(idx);
      c.style.setProperty("--front-color", SYMBOL_COLOR_MAP[sym] ?? "var(--card)");

      const f = document.createElement("div");
      f.classList.add("face");
      f.textContent = sym;

      c.appendChild(f);
      return c;
    }

    function render() {
      grid.innerHTML = "";
      deck.forEach((sym, i) => grid.appendChild(buildCard(i, sym)));
    }

    function cardEl(idx) {
      return grid.querySelector(`[data-idx="${idx}"]`);
    }

    function show(idx) {
      const el = cardEl(idx);
      if (el) el.classList.remove("hidden");
    }

    function hide(idx) {
      const el = cardEl(idx);
      if (el) el.classList.add("hidden");
    }

    function showBoard() {
      grid.classList.remove("grid-hidden");
      finalScoreEl.classList.remove("visible");
      finalScoreEl.textContent = "";
    }

    function displayFinalScore() {
      grid.classList.add("grid-hidden");
      finalScoreEl.textContent = `All pairs matched in ${moves} moves.`;
      finalScoreEl.classList.add("visible");
    }

    // Confetti-js â€œClick here!â€ style: create a canvas and run a short burst.
    // Keep shapes as squares and do not stretch via CSS (only scale canvas size).
    function runCardConfetti(idx) {
      const card = grid.querySelector(`[data-idx="${idx}"]`);
      if (!card) return;

      const scale = 1.35;
      const { width, height } = card.getBoundingClientRect();
      const canvasSize = Math.round(Math.max(width, height) * scale);

      const canvas = document.createElement("canvas");
      canvas.className = "card-confetti";
      canvas.width = canvasSize;
      canvas.height = canvasSize;
      canvas.style.width = `${canvasSize}px`;
      canvas.style.height = `${canvasSize}px`;
      canvas.style.left = `${(width - canvasSize) / 2}px`;
      canvas.style.top = `${(height - canvasSize) / 2}px`;
      // Ensure confetti is in front of the card content
      canvas.style.zIndex = "10";

      const canvasId = `card-confetti-${idx}-${Date.now()}`;
      canvas.id = canvasId;
      card.appendChild(canvas);

      const confetti = new ConfettiGenerator({
        target: canvasId,
        max: 90,
        size: 1.1,
        animate: true,
        props: ["square"],
        colors: [
          [165, 104, 246],
          [230, 61, 135],
          [0, 199, 228],
          [253, 214, 126]
        ],
        clock: 25,
        rotate: true,
        start_from_edge: false,
        respawn: true
      });

      confetti.render();

      window.setTimeout(() => {
        confetti.clear();
        canvas.remove();
      }, 1500);
    }

    function mark(i, j) {
      matched.add(i);
      matched.add(j);

      [i, j].forEach((k) => {
        const c = cardEl(k);
        if (!c) return;
        c.classList.remove("hidden");
        c.classList.add("matched");
        runCardConfetti(k);
      });

      updateMeta();
    }

    async function resolve(i, j) {
      lock = true;
      moves += 1;
      updateMeta();

      if (deck[i] === deck[j]) {
        mark(i, j);
        setStatus("Match!");
      } else {
        setStatus("Nope.");
        await new Promise(r => window.setTimeout(r, Math.round(MISMATCH_DELAY * 1000)));
        hide(i);
        hide(j);
      }

      firstPick = null;
      revealed.clear();
      lock = false;

      if (matched.size === deck.length) {
        displayFinalScore();
        setStatus("");
      }
    }

    async function preview() {
      for (let i = 0; i < deck.length; i++) show(i);
      setStatus("Previewâ€¦");
      await new Promise(r => window.setTimeout(r, Math.round(PREVIEW_SECONDS * 1000)));
      for (let i = 0; i < deck.length; i++) {
        if (!matched.has(i)) hide(i);
      }
      setStatus("Go!");
    }

    function restart() {
      deck = newDeck();
      revealed.clear();
      matched.clear();
      firstPick = null;
      lock = false;
      moves = 0;

      updateMeta();
      render();
      showBoard();
      preview();
    }

    function onGridClick(ev) {
      if (lock) return;

      const card = ev.target.closest?.(".card");
      if (!card) return;

      const idx = Number(card.dataset.idx);
      if (!Number.isFinite(idx)) return;
      if (matched.has(idx) || revealed.has(idx)) return;

      revealed.add(idx);
      show(idx);

      if (firstPick === null) {
        firstPick = idx;
      } else {
        const i = firstPick;
        resolve(i, idx);
      }
    }

    grid.addEventListener("click", onGridClick);
    restartBtn.addEventListener("click", restart);

    restart();
  </script>
</body>
</html>
